# 1. 实验要求

## 1.1 评测要求

学生需要将代码clone到/mnt/cgshare/project/SysYF/中，并将文件夹重命名为CodeGenOpt-Lab，才能进行评测

## 1.2 任务说明

分为必做部分和选作部分，以及完成实验报告，进行答辩

#### 1.2.1 必做部分

在文件夹 SysYF_Pass_Student

#### 1.2.2 选作部分——进阶优化

在文件 SysYF_Pass_student

在必做的基础上，需要自行选择至少**两个不同的优化 Pass **来进行进阶优化，并且设计测试程序来体现优化效果，撰写相应的文档。

## 1.3 评测说明

请勿修改根目录下的 eval.sh，但需要修改相应选题下的 eval.sh



# 2. 必做部分——Part3

### 2.1 编译命令的flag说明

本实验中新增了`-O2`命令行参数，使用`-O2`参数将开启全部优化（默认不开启）。例如：

```shell
./compiler -emit-ir -O2 test.sy -o test.ll
```

同时保留了`-emit-ast`参数用于从AST复原代码，`-check`参数用于静态检查。

若要开启单项优化，`-av`代表开启活跃变量分析。如果需要开启优化或者分析，则必须在命令行中搭配`-O`参数使用，否则无效。比如，若你想开启活跃变量分析或者其他分析优化遍，就需要使用如下命令：

```shell
./compiler -emit-ir -O -av test.sy -o test.ll
```

**注意：**以下两条命令产生的IR是不同的:

```shell
./compiler -emit-ir -O test.sy -o test.ll
./compiler -emit-ir test.sy -o test.ll
```

原因在于`-O`选项会开启Mem2Reg pass，IR会变成SSA格式。

有关flag详情，可以参见[main.cpp](http://cscourse.ustc.edu.cn/exp/src/main.cpp)。



### 2.2 分析与优化 Pass 说明

#### 2.2.1 Pass

Pass 是所有分析与优化 Pass 的基类，定义在 Pass.h 中。

该基类有两个纯虚函数需要子类重写：一个是 `virtual void execute() = 0`，该函数是 pass 的总控函数，该函数会被调用去执行该 pass；另一个是 `virtual const std::string get_name() const = 0`，该函数用于获得该 pass 的名字。

本实验中，所实现的分析和优化 pass 均需继承自该类。

需要重写上述的 `execute` 和 `get_name` 函数。可以参考 Mem2Reg 和 DominateTree 是如何实现的。



#### 2.2.2 PassMgr

该类负责管理 Pass，定义在 Pass.h 中。

该类有两个私有成员变量：module, pass_list

该类有两个共有函数：addPass, execute。前者用于向 pass_list 中添加 pass, 每次添加采用 push_back 的方式。后者用于顺序调用 pass_list 中的 pass 的 execute 函数。

使用示例可见 main.cpp

```c++
PassMgr passmgr(m.get());   // m.get() 得到的是 Module 对象的指针
            passmgr.addPass<DominateTree>();
            passmgr.addPass<Mem2Reg>();
            if(optimize_all){
                passmgr.addPass<ActiveVar>();
                //  ...
            }
            else {
                if(av){
                    passmgr.addPass<ActiveVar>();
                }
                //  ...
            }
            // 应该在这里加入检查中间表示的扫描
            Check IRChecker(m.get());
            IRChecker.execute();
            if(IRChecker.get_err_type()){   // 中间表示有问题
                std::cout << "err type" << IRChecker.get_err_type() << std::endl;
                return 0;
            }
            passmgr.execute();  // 执行扫描
```



#### 2.2.3 Mem2Reg

用于将 IR 转换成 SSA 形式的 IR

LLVM 中，局部变量被生成为 alloca/load/store 的形式，在 mem2reg 的 pass 中，会识别出局部变量的 alloca，把它提升为 SSA value，在提升为 SSA value 时会对应地消除 store 和 load，修改为 SSA 的 def-use/ use-def 关系，并在恰当的位置安插 Phi 和进行变量重命名。

具体实现见 Mem2Reg.cpp

本实验中的所有优化均基于 SSA 形式的 IR



### Mem2Reg



### 活跃变量分析

需要补充 ActiveVar.h 和 ActiveVar.cpp 中的 `ActiveVar` 类，来实现一个完整的活跃变量分析算法，分析所有 BasicBlock 块的入口和出口的活跃变量，该算法基于 SSA 形式的 CFG（控制流图）

![image-20221228182624493](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20221228182624493.png)

![image-20221228182654698](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20221228182654698.png)

在本次实验的框架中，`BasicBlock` 类实现了 4 个和活跃变量分析相关的函数，需要调用他们，设置所有 `BasicBlock` 的入口和出口处的活跃变量，完成实验：

```c++
// 设置该BasicBlock入口处的活跃变量集合
void set_live_in(std::set<Value*> in){live_in = in;}
// 设置该BasicBlock出口处的活跃变量集合
void set_live_out(std::set<Value*> out){live_out = out;}
// 获取该BasicBlock入口处的活跃变量集合
std::set<Value*>& get_live_in(){return live_in;}
// 获取该BasicBlock出口处的活跃变量集合
std::set<Value*>& get_live_out(){return live_out;}
```

根据框架，每个 function 中的 BasicBlock 组成一个流图。

具体到一个 BlockBasic，那就对其中的 Instruction 分类进行处理。

+ 算数：两个 use，一个 def

+ 比较：两个 use，一个 def

+ `phi`：phi 的引入使得上述数据流方程需要做一些调整。

  > 由于`phi`指令的特殊性，例如`%0 = phi [%op1, %bb1], [%op2, %bb2]`如果使用如上数据流方程，则默认此`phi`指令同时产生了`op1`与`op2`的活跃性，而事实上只有控制流从`%bb1`传过来才有`%op1`的活跃性，从`%bb2`传过来才有`%op2`的活跃性。因此你需要对此数据流方程做一些修改。

​	其他指令产生的活跃性，也即 use，可以直接向前驱块传递，但是如上所述，phi 指令产生的活跃性只能向**某一个**前驱块传递。

​	对 phi 指令产生的活跃单独记录，不计入当前 BasicBlock 的 $use_B$ 集合，而是记录进一个新集合 PIN。

​	IN 集合的计算不变（实际为不计入 phi 指令产生的活跃）

​	OUT 集合的计算，在原有的基础上，再**并**上”每个后继块的 PIN 集合中，**该向**当前 BasicBlock 传递的活跃变量“。

​	根据上述数据流方程，那就迭代，直到各集合不再发生变化。

​	具体实现中，使用 STL 中的 set：

+ set 的比较可以直接比较
+ set 的取并操作：`set_union(A.begin(),A.end(),B.begin(),B.end(),inserter( C1 , C1.begin() ) )`
  前四个参数依次是第一的集合的头尾，第二个集合的头尾。第五个参数的意思是将集合A、B取合集后的结果存入集合C中。
+ 类似的，还有取差集操作



缺一个活跃变量，而且是大面积的缺同一个

我生成的代码里没有涉及到这个，op36，问题是我也看不到它生成的汇编码

根据原本的 SysYF 代码推测，问题出在全局变量上

把全局变量算给 main？

![image-20230104201630263](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20230104201630263.png)

![image-20230104213657641](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20230104213657641.png)

[编译原理学习笔记（七）：优化代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/331795662)

# 2. 公共子表达式删除 CSE

## 2.0 修改部分

新增：CSEin.h 	CESin.cpp	CSEglo.h	CESglo.cpp

修改 src\Optimize\CMakeLists.txt	main.cpp



CSEin.h 	CESin.cpp 已传

## 2.1 基本块内 CSE

因为是顺序执行，所以实现思路比较简单：维护一个指令的 set，顺序遍历各条指令，如果之前出现过，则删除；如果没有，则加入 set

需要做：

+ 判断表达式相等：
  + 如果操作数是常量，会出问题

+ 删除

## 2.2 全局 CSE

### 2.2.1 参考资料

[编译器笔记54-代码优化-删除全局公共子表达式和复制语句 - 简书 (jianshu.com)](https://www.jianshu.com/p/3844b3dd8ece)

[(31条消息) 【编译原理笔记18】代码优化：活跃变量分析，可用表达式分析_枇杷鹭的博客-CSDN博客_编译原理 活跃变量分析](https://blog.csdn.net/weixin_42815609/article/details/108022060)

主要参考了第二篇文章。

首先做可用表达式分析。

记录每个表达式第一次出现的指令。注：由于基本块之间的并不是单一线性的，所以某个表达式的第一次出现未必是单条指令。

遍历指令，若该指令含有公共表达式，且不是第一次出现，就把该指令删除，并把该指令等号左边的后续引用用该表达式的第一次出现代替。

### 2.2.2 可用表达式分析

![image-20221231154807455](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20221231154807455.png)

![image-20221231154824990](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20221231154824990.png)

### 2.2.3 公共子表达式删除

![image-20221231154535974](C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20221231154535974.png)



需要改成 vector，只有那一部分改成 set





G1	A2	实现了多种优化，可以看出在课本基本内容外有自己的调研和设计	可以再增加一些自己的测试样例

G2	84	公共子表达式删除用01串表示IN和OUT，这个思想很棒。测试样例设计得很好，而且运行时间上也比较有说服力，	建议再多实现几个优化。

G3	80	只有两位同学，能够完善地完成实验；而且可以看出对于给出的代码框架有一个比较好的理解，能够很好地使用框架提供的接口	建议再实现一些其他优化

G4	79	答辩过程中对于死代码删除的讲解条理清晰	可以再加一些其他的优化

|      |      |      |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |

1. 



G2：E_kill 为空，



