# 实验报告

## 必做部分

### 支配树

#### B1-1

​		若 $x$ 和 $y$ 支配 $b$，则从流图起点开始，每条到达 $b$ 的路径都要经过 $x$ 和 $y$。假设 $x$ 和 $y$ 互不支配，即同时存在从起点到 $x$ 且不经过 $y$ 和 从起点到 $y$ 且不经过 $x$ 的路径。则由下可推出矛盾。

​		任选一条从起点到 $b$ 的路径，由 $x$ 和 $y$ 支配 $b$， $x$ 和 $y$ 会同时在该路径上出现，不妨设 $x$ 先于 $y$ 出现，则存在从 $y$ 到 $b$ 且不经过 $x$ 的路径 $P_2$，又存在从起点到 $y$ 且不经过 $x$ 的路径 $P_1$。因为 $y$ 支配 $b$，所以 $P_1$ 和 $P_2$ 不会有 $y$ 以外的重复节点；否则，设正向遍历  $P_1$ 节点同时点反向遍历 $P_2$ 节点碰到的第一个相同节点为 $t$，则起点到 $t$、$t$ 到 $b$ 构成起点到 $b$ 的路径，且不经过 $y$，与 $y$ 支配 $b$ 矛盾。从而存在从起点到 $b$ 且不经过 $x$ 的路径（将 $P_1$ 和 $P_2$ 拼接），与 $x$ 支配 $b$ 矛盾。对于 $y$  先于 $x$ 出现的情况，同理可推出矛盾。

​		因此若 $x$ 和 $y$ 支配 $b$，则要么 $x$ 支配 $y$，要么 $y$ 支配 $x$。 

#### B1-2

​		不一定要按照后序的逆序进行。因为该迭代算法基于数据流分析，数据流分析是流不敏感的，即算法的结果并不依赖于迭代的顺序。

#### B1-3

​		不一定要按照后序的逆序进行。如文章中 Figure 4 中的例子按照正序的后序进行遍历也可以得到正确的结果。

#### B1-4

​		作用是寻找共同支配两个节点的最近节点，从而快速计算两个结点支配节点集合的交集。

​		`while` 循环中的小于号不能改成大于号。因为在支配树中，深度深的节点编号较小，从而 doms[finger] > finger，因此如果改成大于号，会陷入死循环。

#### B1-5

​		时间上的优势：计算集合的交集速度更快，无需逐一比对两个集合的元素并且将其拷贝入结果集合，只需寻找两个节点的最近公共祖先。

​		空间上的优势：无需为每个节点开辟一块空间存储支配节点集合，对于每个节点只存储其直接支配节点，节省空间。

#### B1-6

​		在反向支配树的构建过程中，选择最后一条指令为返回指令的基本块作为 EXIT 节点。

​		因为流图的最后一个基本块不一定没有后继节点，例如最后一个基本块的最后一条语句是跳转到含返回指令的基本块的情况。而最后一条指令为返回指令的基本块不会有后继，因此可以作为反向深度优先遍历的入口。



### Mem2Reg

#### B2-1

首先流程以一个函数的定义为基本，再对其中的基本块及其之间的联系进行优化。对于一个定义函数，流程如下：

0. 调用`insideBlockForwarding`，在一个基本块内进行简单优化。主要的工作是对于非指针局部变量的 `Store` 和 `Load` 指令：
   - 对于 `Load` 的局部变量进行 `Forwarding` ，使用该变量最新的值更新所有用到该`Load`对应寄存器的指令的指令数，并在更新后将该 `Load` 指令删除
   - 删除基本块中的多次赋值 `Store` ，只保留一次赋值，待后面继续处理
0. 调用 `genPhi` ，在每个`global var`的支配边界`dom_frontier`基本块前对每个`global var`对应的变量插入不完整的 $\varphi$ 指令
0. 调用 `set_print_name` ，为每个函数添加其对应的 `label` 且其中每条指令添加 `op*` 的名字
0. 调用 `valueDefineCounting` ，将 $\varphi$ 指令和 `store` 指令标识出来的变量加入 `define_var`
0. 从入口基本块开始调用`valueForwarding` ，用DFS的方式完成 $\varphi$ 指令，并利用 `value_status` 对基本块中指令完成跨基本块的 `Forwarding`
0. 调用 `removeAlloc` ，删除所有 `Mem2Reg` 后无效的 `Alloc` 指令

#### B2-2

以下面的`.sy`文件为例说明

```c
//.sy
int main()
{
    int a = 10;
    int b;
    int c[10];
    b = a;
    while(a > 0)
    {
        b = a;
        if(a < 5)
        {
            a = a - 2;
        }
        else
        {
            a = a - 1;
        }
    }
    return a + b;
}
```

##### 总览

* `Mem2Reg`可能会删除的指令类型是哪些？对哪些分配(alloca)指令会有影响？
    - 可能会删除的指令类型是 `load,store,alloca`
    - 对`int,float`和指针类型的分配指令有影响

如下面第一个基本块中，`%op0`，`%op1`，`%op2`三个`alloca`指令被删除，且`store`和`load`的指令也同样被删除；同时数组分配的`alloca`并未被删除

```llvm
; before
label_entry:
  %op0 = alloca i32
  %op1 = alloca i32
  store i32 10, i32* %op1
  %op2 = alloca i32
  %op3 = alloca [10 x i32]
  %op4 = load i32, i32* %op1
  store i32 %op4, i32* %op2
  br label %label6

;after
label_entry:
  %op3 = alloca [10 x i32]
  br label %label6
```

##### insideBlockForwarding阶段

在该阶段存储了对局部变量进行修改的列表`defined_list`，对load指令进行forward的列表`forward_list`，局部变量最新的值`new_value`，将要删除的指令的列表`delete_list`；对于IR中 `Load` 的局部变量的引用进行 `Forwarding` ，之后删除该 `Load` 指令；删除基本块中局部变量的多次赋值 `Store` ，只保留一次赋值，待后面继续处理

例子中因为没有全局变量和数组变量的引用，所以基本在该阶段所有的`load`指令均会被删除

* 在基本块内前进`insideBlockForwarding`时，对`store`指令处理时为什么`rvalue`在`forward_list`中存在时，就需要将`rvalue`替换成`forward_list`映射中的`->second`值？
    - `forward_list` 中的指令之后会删除，并将 `load` 的值传播到后面。如果此处没有替换，其更新的值不会反映在其后面 `new_value` 的更新中，而会变成 `load` 这条将要被删除的指令

* 在基本块内前进时，`defined_list`代表什么含义？
    - 一个基本块中最后对局部变量更新的变量和其对应更新的指令映射`map`

##### genPhi阶段

该阶段存储了活跃在不同基本块间的变量列表`globals`，在某个基本块进行修改的map`defined_in_block`；在每个`global var`的支配边界`dom_frontier`基本块前对每个`global var`对应的变量插入不完整的 $\varphi$ 指令

例如下面的代码中，该该阶段会在对应的位置放置没有后面操作数的`phi`指令

```
label6:                                                ; preds = %label_entry, %label27
  %op28 = phi i32 [ 10, %label_entry ], [ %op29, %label27 ]
  %op29 = phi i32 [ 10, %label_entry ], [ %op30, %label27 ]

; ....
label27:                                                ; preds = %label21, %label24
  %op30 = phi i32 [ %op26, %label24 ], [ %op23, %label21 ]
```

* 生成phi指令`genPhi`的第一步两层for循环在收集什么信息，这些信息在后面的循环中如何被利用生成Phi指令？
    - `global` 与 `defined_in_block` 集合。`global` 包含所有跨基本块的活动变量名； `defined_in_block` 集合记录了每个变量每次被重新赋值时所在的基本块
    - 对 `global` 每个变量进行处理，而处理的队列中包含了 `defined_in_block` 记录的所有基本块

##### valueDefineCounting阶段

在该阶段会修改 `define_var` 变量以便后面使用，记录了每个基本块中修改的变量值

* `valueDefineCounting`为`defined_var`记录了什么信息
    - 每个基本块中修改的变量值，包括 `phi` 指令和 `store` 指令所造成的修改

##### valueForwarding阶段

该阶段存储了活动变量的值的所有变化`value_status`，已经访问的基本块`visited`，将要删除的指令`delete_list`；该阶段用DFS的方式完成 $\varphi$ 指令，并利用 `value_status` 对基本块中指令完成跨基本块的 `Forwarding`

如上面的例子，phi指令的操作数会填上

```
label6:                                                ; preds = %label_entry, %label27
  %op28 = phi i32 [ 10, %label_entry ], [ %op29, %label27 ]
  %op29 = phi i32 [ 10, %label_entry ], [ %op30, %label27 ]

; ....
label27:                                                ; preds = %label21, %label24
  %op30 = phi i32 [ %op26, %label24 ], [ %op23, %label21 ]
```

同时还有跨基本块的调用如下

```
label_ret:                                                ; preds = %label17
  ret i32 %op20

label17:                                                ; preds = %label6
  %op20 = add i32 %op29, %op28
  br label %label_ret
```

* `valueForwarding`在遍历基本块时采用的什么方式
    - 使用DFS的方式

* `valueForwarding`中为什么`value_status`需要对phi指令做信息收集
    - `value_status` 记录的是活动变量的值的所有变化，而 `phi` 指令本身就是可能改变活动变量值的指令

* `valueForwarding`中第二个循环对`load`指令的替换是什么含义
    - 用活动变量最近的值替换所有引用，因为引入了 `phi` ，不需要担心不同基本块入口导致不同

* `valueForwarding`中出现的`defined_var`和`value_status`插入条目之间有什么联系
    - `value_status` 插入条目对应着当前DFS枝上所有基本块的 `defined_var` 之和


#### B2-3

因为若只有一层条件分支或循环，那么其内部仅含一个基本块，难以体现基本块与基本块之间传递局部变量寄存器的优化



### 活跃变量分析

#### B3-1

活跃变量的定义为：变量 x 的值在 p 点开始的某条执行路径上被引用，则说 x 在 p 点活跃，否则称 x 在 p 点已经死亡。

需要计算每个数据块的两个集合：

+ IN[B]：块 B 开始点的活跃变量集合
+ OUT[B]：块 B 结束点的活跃变量集合
+ use_B：块 B 中有引用且在引用前无定值的变量集合
+ def_B：块 B 中有定值的变量集合

对于每个块，对其中的每条指令分类处理，每条指令会涉及到哪些操作数，可参考 `SysYFIR.md` 文档，比如比较指令，会使用到两个变量，定值一个变量，那就将使用到的变量加入 use_B，定值的变量从 def_B 中删除。

phi 指令没有在 `SysYFIR.md` 中出现，而且由于它的特殊性：

> 由于`phi`指令的特殊性，例如`%0 = phi [%op1, %bb1], [%op2, %bb2]`如果使用如上数据流方程，则默认此`phi`指令同时产生了`op1`与`op2`的活跃性，而事实上只有控制流从`%bb1`传过来才有`%op1`的活跃性，从`%bb2`传过来才有`%op2`的活跃性。因此你需要对此数据流方程做一些修改。

在后续数据流等式中需要特殊处理，所以它使用的变量不加入 use_B，而是加入一个新的集合 PIN，记录当前块产生的 phi 指令。但是它定值的变量仍需加入 def_B 集合。

然后迭代数据流等式，直到每个基本块的 IN 和 OUT 集合都不发生改变。

原数据流等式（来自课程 PPT）
$$
IN[B] = use_B ∪ (OUT[B]-def_B)
\\

OUT[B] = ∪_{S是B的后继}  IN[S]
$$
其他指令产生的活跃性，也即 use，可以直接向前驱块传递，但是如上所述，phi 指令产生的活跃性只能向**某一个**前驱块传递。

所以修改数据流等式为：
$$
IN[B] = use_B ∪ (OUT[B]-def_B)
\\
OUT[B] = (∪_{S是B的后继}  IN[S]) ∪ (S的PIN中来源于B的活跃)
$$
根据上述数据流方程，迭代，直到各集合不再发生变化。

值得一提的是，上述操作中涉及到了集合的并集和差集，所以选用 STL 中的 set，它提供了集合的上述操作。



### 检查器

#### B4-1

检查器检查的方面如下：

1. 每个基本块是否以跳转或返回指令结尾
2. 每条指令的操作数在使用前是否定值
3. 每个基本块的前驱后继关系是否存在问题
4. 每条指令的 def_use 链是否正确维护

检查上述方面的原因如下：

1. 强度削弱等优化过程中会在基本块中插入新指令，如果插入位置不对可能会把其他指令插到基本块末尾，导致这些指令无法正常执行，也可能会导致无法正确找到 EXIT 标准块
2. 代码外提、公共子表达式等优化过程中会删除部分指令，如果没有正确将被删除的变量进行替换，会出现某些变量尚未定值就被引用的情况，代码执行会出现问题
3. 常量折叠等优化过程中可能会删除一些没有语句的空基本块，此时如果前驱后继关系没有正确维护，则在遍历流图时会出现问题
4. 强度削弱等优化过程中会删除、添加一些变量，如果 def_use 链没有及时更新，可能会导致常量折叠等需要用到 def_use 链的优化过程出现错误



各个部分的实现逻辑如下。

##### 检查基本块结尾

​		遍历各函数的各基本块，调用其 `get_terminator()`方法，如果得到的是`nullptr`，则返回错误，反之基本块正常结尾。

##### 检查操作数是否预先定值

​		首先记录每个基本块中定值的变量（记为 $def[B]$），然后利用数据流分析的方法记录下到每个基本块入口处一定会被定值的变量分别有哪些。数据流等式如下（其中 $IN[B]$ 和 $OUT[B]$ 分别表示在 B 的入口处和出口处一定会有定值的变量集合）：

​		$IN[B] = \cap\,OUT_{pre 是 B的前驱}[pre]$

​		$OUT[B] = IN[B]\cup def[B]$

​		设基本块 B 入口处一定被定值的变量集合为 Var，则在检查基本块 B 中的操作数是否被事先定值时，先将 Var 加入定值集合，再从上往下遍历指令，如果指令对某变量定值，则将该变量加入定值集合。对于 store 指令，也将 store 的对象加入定值集合。如果碰到某个操作数不在定值集合里的情况，则返回错误。另外，对于全局变量和参数，默认其经过定值。

##### 检查前驱后继关系

​		遍历每个基本块，遍历其前驱节点集合（可利用 `get_pre_basic_blocks()`方法获得基本块的前驱集合），并检查该基本块是否在每个其前驱节点的后继集合中。再遍历其后继节点（可利用 `get_succ_basic_blocks()`方法获得基本块的后继集合），并检查该基本块是否在其每个后继节点的前驱集合中。

##### 检查 def_use 链

​		检查 def_use 链包括两个方面，一是遍历变量的 use 链（可利用 `get_use_list()` 方法获得一个变量的引用链），假设 use 链的单个元素为二元组（val,num），检查指令 val 编号为 num 的操作数是否为当前变量，不是则返回错误；二是遍历每条指令的操作数（可利用 `get_num_operand()` 和 `get_operand()` 分别获得一条指令的操作数个数和某个操作数），如果该操作数为变量，则检查该操作数的引用链中是否有该变量，且相应的操作数编号是否正确。

​		检查 def_use 链可以保证不会出现引用一个变量但是没有正确出现在该变量引用链的情况，也不会出现没有引用该变量但出现在该变量引用链中的情况。

##### 错误输出

​		另外，Check 部分还实现了多种错误的输出，以上四类错误以二进制位的形式出现在变量 err_type 中，例如如果 err_type 的最低位为 1，表明有基本块的结尾出现问题。具体的对应关系如下（截取自 Check 类的 `execute()` 方法）。

```cpp
        if(!(err_type&1) && !check_end(f)){	// 结尾是否正常
            err_type |= 1;
        }
        if(!(err_type&2) && !check_ops(f)){	// 操作数是否定值
            err_type |= 2;
        }
        if(!(err_type&8) && !check_bb(f)){	// 前驱后继关系是否正确
            err_type |= 8;
        }
        if(!(err_type&16) && !check_def_use(f)){	// def_use 链是否正常维护
            err_type |= 16;
        }
```

​	  `main.cpp` 在所有优化被加入后，将 Check 加入 passmgr 中，对优化后的中间代码进行检查，如果出现问题则输出错误信息并中止编译程序。



