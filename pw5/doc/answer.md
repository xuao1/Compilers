## 第二关

### 问题 1-1

> 请阅读`include/SyntaxTreePrinter.h`和`src/SyntaxTreePrinter.cpp`，总结`VarDef`、`InitVal`、`LVal`、`FuncDef`、`FuncFParamList`、`FuncParam`、`BlockStmt`等节点类的结构及其`visit`方法的实现特点。

#### 结构

这些节点都继承了节点 `Node`，`Node` 中存放了节点的位置，声明了 `accept` 函数

`VarDef`：类型，名字，一些标记波尔类型，指向表达式的指针容器，指向初始化内容的指针，`accept`

`InitVal`：指向初始化内容的指针容器，指向表达式的指针，`accept`

`LVal`：名字，指向表达式的指针容器，`accept`

`FuncDef`：返回类型，指向参数列表的指针，名字，语句块，`accept`

`FuncParamList`：指向参数的指针容器，`accept`

`FuncParam`：名字，参数类型，指向表达式的指针容器，`accept`

`BlockStmt`：指向语句块的指针容器，`accept`

总结起来，基本上是包含了当前节点的一些必要信息和指针，以及 `accept`

#### `visit` 方法的实现特点

`VarDef`：打印缩进，根据节点的 `is_constant` 标记，决定是否打印 `const`；打印变量类型和名字；对于数组，打印方括号，并且调用相应的具体 `accept` 打印数组每一维的长度；若有初始化信息，打印 `=`，并且调用 `accept` 打印初始化信息；打印 `;`.

`InitVal`：根据节点的 `isExp` 判断节点是表达式还是表达式列表。对于表达式，调用表达式的`accept` 进行输出；对于表达式列表，分别对其中每个表达式调用 `accept` 进行输出，以及输出大括号和逗号。

`LVal`：打印节点名字，如果当前节点为数组的某个元素，则需要打印方括号和数组每一维的 index，后者通过 `accept` 实现。

`FuncDef`：打印返回值和函数名字，调用分别调用各自的 `accept` 打印参数和函数体。

`FuncParamList`：对每个参数，调用 `accept` 进行输出，并输出逗号。

`FuncParam`：打印参数类型和名字，如果参数是数组，打印方括号，对于数组的每一维，调用  `accept` 打印当前维长度，或者只有方括号。

`BlockStmt`：打印大括号和缩进，对于语句块，调用 `accept` 打印

总结：对于简单的数据直接打印，对于需要计算处理的内容调用相应的 `accept`，若包含指针容器，则依次遍历并处理。

### 问题 3-1

> 请提交一份实验总结，该实验总结必须包含以下内容：
>
> 1. 你在实验过程中遇到的困难与解决方案
> 2. 你认为的实验难点与考察倾向
> 3. 你的整体实现思路与实现亮点

#### 困难与解决方案

**困难一：**函数声明时，语句块是 `Block`，其他如 if、while 的 statement，是 `Stmt`。概括来说，Block 是可以推出多个 BlockItem，BlockItem 可以推出 Stmt，反过来，Stmt 可以是用分号间隔开的表达式，但也可以是 Block。这个问题在大部分情况下是没问题的——直接对于每个 Stmt 划分作用域即可。但是有一种情况特殊，那就是函数声明时，函数的形参也是和语句块归于同一个作用域的。但是函数的形参和语句块是分开 accept，无法如果是只对于 Stmt 内部划分作用域，是无法解决函数声明时形参不在作用域里的问题。

**解决：**函数声明时，必须将形参和语句块放在同一个作用域，这就要求在 accept 形参之前，就要新创建一个作用域并压栈（作用域我是用栈来实现的），等到形参和语句块都分析完后，再弹栈。但是在 Stmt 内，是要新建一个作用域。解决方案就是：设置一个变量， 记录当前压栈的作用域数目，这个变量通常会随着压栈和弹栈加减，但是函数声明时，压栈但是这个变量不加一，在 Stmt 时，就可以根据当前栈内元素是否与设置的变量一致来进行判别。

**困难二：**要修改的是 `SyntaxTreeChecker.cpp` 和 `SyntaxTreeChecker.h`，但是用到的变量与类型是在其他源文件里定义，而且还需要参考 `sysyfParser.yy` 了解每个非终结符的会产生什么符号。比如在写 `VarDef` 的 visit 函数时，我误将他的一个右部的变量 `initializers` 认为是类型，结果没有它的 accept 函数，所以就没有对其分析。

**解决：** 我将每个语法符号涉及到的变量都复制到了其 visit 函数前，一目了然。

**困难三：**时间紧张，与四门期中考试和两门其他实验在同一时间段

**解决：**抓紧时间写...

#### 实验难点与考察倾向

我觉得最难的还是理解 C++ 的一些内容，所以当写完第三关以后，第四关也就比较容易了。一方面要求写的时候要熟悉用到的一些 STL 的方法，另一方面也要时刻提醒自己用 “AST” 的思路去理解代码——分析当前符号时，如果它还有一些指针指向其他符号，那也要分析。

不过由于给出了 `SyntaxTreePrinter.cpp` 作为参考，难度也不至于过大。

考察倾向我认为就是 C++ 的使用和对 AST 的理解。

#### 整体实现思路与亮点

维护一个栈，作为符号表，栈里每个元素对应一个作用域，具体作用域用 map 实现。再维护一个 map，记录函数及其变量，用于检查变量个数与类型的检查。

对于每个节点，如果它还有指向其他节点的指针，则需要分析这些指针对应的节点。

### 问题 3-2

> 处理变量声明时，是应该先处理变量的初始化还是先把该变量加入符号表？处理函数定义时，是先处理函数体还是先把函数名加入符号表？

处理变量声明时，应该先处理变量的初始化，再把变量加入符号表。

处理函数定义时，应该先将函数名加入符号表，以处理递归调用。

### 问题 3-3

> 有人说如果本次实验允许修改抽象语法树的话，他想给 `Expr` 添加一个属性用于判断是否为整数，而不是在 `SyntaxTreeChecker` 内部设置该属性。这种做法有什么缺点？
>
> 另一个人说，完成本次实验后 `SyntaxTreeChecker` 类过于庞大了，他想拆成多个类，每个类处理一种可能的语义错误，这种做法又有什么缺点？

**问题一：**无法保证 AST 的简洁性，如果因为一些具体的类型检查的需要，就给 AST 的节点引入许多额外的信息，会使得 AST 比较冗杂，增加内存开销。

**问题二：**每检查一种语义错误，都需要从头遍历一遍语法树，增大了运行开销。

### 问题 3-4

> 如果想给错误人为地规定一个优先级，例如，如果取模运算是最高优先级，那么语义检查器在遇到存在取模运算错误的程序时，必定报取模运算错误，也即`ErrorType::Module`。

**方法一：**受问题 3-3 的启发，可以对不同的语义错误分开检查，拆分成多个类，优先级高的错误类型优先检查。

**方法二：**遇到错误时，不会立即退出，而是将错误保存，采取一定的错误恢复机制（如紧急方式的错误恢复），继续向下查找错误。最后遍历保存的错误，将规定的最高优先级的错误输出（当前也可以输出所有错误）。