### 汇编码分析

### 第一问

> 结合使用-E（预处理器）、-S、-c、-o、-m32、-m64等选项，对其输出结果进行大致的阅读了解，在作业解答中指出做了哪些类型的变换

+ `-E`：增加了大量的路径信息，使用 `typedef` 定义了类型名称，以及一些 `extern` 语句，涉及到如 `scanf` 和 `printf` 的内容
+ `-S -m32`：生成了32位的汇编码
+ `-S -m64`：生成了64位的汇编码
+ `-c` ：只进行了预处理、编译和汇编，把源程序做成 obj 文件，直接打开 sort.o 文件是乱码

### -m32和-m64的不同

+ 执行堆栈检查的内容不同：32位汇编的是 `%gs:20`，64位汇编的是 `%fs:40`
+ 参数传递方式不同：32位是将参数入栈，64位是使用寄存器进行传递参数
+ 一些操作的后缀不同，如 `pushq` 和 `pushl`，在 H1 中解释过
+ 使用到的寄存器不同，不过64位也会使用和32位汇编名称相同的寄存器
+ 64位汇编中有这样一条独有的指令 `cltq`，它的作用是将 %eax 签名扩展为 %rax。它是`movslq %eax, %rax` 的简短形式，节省了代码字节
+ CFI 信息有所不同

### 两编译器汇编码的不同（gcc）

+ clang 使用了 p2align，用来填充以在 16 字节边界上对齐
+ gcc 使用了 CFI，而 clang 32位中没有使用
+ gcc 生成的汇编代码会直接操作存储在内存中的值，而 clang 生成的汇编代码会先将内存中的数据移到寄存器中，再进行操作
+ gcc 生成的汇编码，在执行 for 循环的判断终止条件时，采用的指令是“小于（或小于等于）则跳转"执行循环体，clang 采用的指令是“大于则跳转”，jmp 的目标地址是退出循环后执行的代码，jmp 之后顺序执行的是循环体代码
+ gcc 的32位采用压栈的方式传参，64 位采用寄存器传参。clang 32位采用保存在内存里传参，clang64位采用集群器
+ gcc 有生成的汇编代码有堆栈检查，clang 生成的汇编代码没有

### 解释汇编码

#### gcc32位

```assembly
.file   "sort.c"
        .text
        .globl  mysort
        .type   mysort, @function
mysort:
.LFB2:
        .cfi_startproc
        pushl   %ebp            # 保存main函数的%ebp
                                # 被调用者保存
        .cfi_def_cfa_offset 8   
        .cfi_offset 5, -8
        movl    %esp, %ebp      # %ebp=$esp,更新当前函数的基址
        .cfi_def_cfa_register 5
        subl    $16, %esp       # 扩栈，%esp始终指向栈顶
        # 各变量的存储位置：i是-12，n是8,j是-8，12是num,-4是tmp
        movl    $1, -12(%ebp)   # i=1
        jmp     .L2             # 跳转到L2
.L6:                            # 第一层循环的循环体
        movl    $1, -8(%ebp)    # j=1
        jmp     .L3             # 跳转到L3
.L5:                            # 第二层循环的循环体
        movl    -8(%ebp), %eax  # %eax=j
        leal    0(,%eax,4), %edx# $edx=j*4        
        movl    12(%ebp), %eax  # %eax=num的首地址 
        addl    %edx, %eax      # %eax=num+j
        movl    (%eax), %edx    # %eax=num[j]
        movl    -8(%ebp), %eax  # %eax=j
        addl    $1, %eax        # %eax=j+1
        leal    0(,%eax,4), %ecx        
        movl    12(%ebp), %eax
        addl    %ecx, %eax
        movl    (%eax), %eax    # 以上5行，是取num[j+1]
        cmpl    %eax, %edx      # 比较num[j]和num[j+1]
        jle     .L4             # 如果num[j]<=num[j+1],跳转到L4
                                # 否则接下来执行交换操作
        movl    -8(%ebp), %eax  # %eax=j
        addl    $1, %eax        
        leal    0(,%eax,4), %edx
        movl    12(%ebp), %eax
        addl    %edx, %eax
        movl    (%eax), %eax    # %eax=num[j+1]
        movl    %eax, -4(%ebp)  # tmp=num[j+1] 
        movl    -8(%ebp), %eax  # %eax=j
        addl    $1, %eax
        leal    0(,%eax,4), %edx
        movl    12(%ebp), %eax
        addl    %eax, %edx      # %edx=num+j+1
        movl    -8(%ebp), %eax
        leal    0(,%eax,4), %ecx
        movl    12(%ebp), %eax
        addl    %ecx, %eax      # %eax=num+j
        movl    (%eax), %eax    # %eax=num[j]
        movl    %eax, (%edx)    # num[j+1]=num[j]
        movl    -8(%ebp), %eax  
        leal    0(,%eax,4), %edx
        movl    12(%ebp), %eax
        addl    %eax, %edx      # %edx=num+j
        movl    -4(%ebp), %eax  # %eax=tmp
        movl    %eax, (%edx)    # num[j]=tmp
.L4:
        addl    $1, -8(%ebp)    # j++
.L3:
        movl    -8(%ebp), %eax  # %eax=j
        cmpl    8(%ebp), %eax   # 比较j和n
        jl      .L5             # 若j<n,执行L5
        addl    $1, -12(%ebp)   # i++
.L2:
        movl    -12(%ebp), %eax # %eax=i
        cmpl    8(%ebp), %eax   # 比较i与n
        jle     .L6             # 若i<=n，执行循环体L6
        nop     
        leave                   # 出循环，mysort也就结束了，弹出原%ebp，即恢复main函数的基址%ebp
        .cfi_restore 5
        .cfi_def_cfa 4, 4
        ret                     # 返回main函数
        .cfi_endproc
.LFE2:
        .size   mysort, .-mysort
        .section        .rodata
.LC0:
        .string "%d"
.LC1:
        .string "%d "
        .text
        .globl  main
        .type   main, @function
main:
.LFB3:
        .cfi_startproc
        leal    4(%esp), %ecx   # %ecx=%esp+4
        .cfi_def_cfa 1, 0
                                # 会先保存执行 main函数之前的基址和栈顶寄存器，main函数return前恢复
        andl    $-16, %esp      # 置%esp末四位为0
        pushl   -4(%ecx)        # 原栈顶%esp入栈
        pushl   %ebp            # 基址寄存器入栈
        .cfi_escape 0x10,0x5,0x2,0x75,0 
        movl    %esp, %ebp      # %ebp=%esp,置新的基址
        pushl   %ecx            # %ecx 入栈，这里应该是返回地址
        .cfi_escape 0xf,0x3,0x75,0x7c,0x6
        subl    $36, %esp       # 为main函数在栈里开辟空间
        movl    %gs:20, %eax    # %eax=%gs:20，为后续执行堆栈检查做准备
        movl    %eax, -12(%ebp) # 将%gs:20存入内存
        xorl    %eax, %eax      # 置%eax为0
        subl    $8, %esp        # 扩栈
        leal    -28(%ebp), %eax # %eax=%ebp-28,此时的%eax就是n输入后保存的位置
        pushl   %eax            # n保存的位置入栈，作为scanf子函数的参数                   
        pushl   $.LC0           # 入栈
        call    __isoc99_scanf  # scanf
        addl    $16, %esp       # n已经输入，其存放位置已经被使用，所以出栈
        movl    -28(%ebp), %eax # 取出n，保存在%eax中
        sall    $2, %eax        # %eax<<2，应该是在求 sizeof(int)*n
        subl    $12, %esp       # 扩栈
        pushl   %eax            # sizeof(int)*n 入栈，作为 malloc 子函数的参数
        call    malloc          # malloc
        addl    $16, %esp       # 子函数结束，退栈，%esp仍指向栈顶        
        movl    %eax, -16(%ebp) # malloc 的返回值被保存
        movl    $1, -24(%ebp)   # -24(%ebp)的位置存i，置i=1,
        jmp     .L8             # 跳转指令
.L9:
        # 注：内存中，相对于%ebp的偏移，-24是i,-16是num首地址，-28是n,-20是j
        movl    -24(%ebp), %eax # %eax=i
        leal    0(,%eax,4), %edx# %edx=i*4
        movl    -16(%ebp), %eax # eax=num[]
        addl    %edx, %eax      # eax=num+i,即num[i]的存放位置
                                # 这里严格来说是num[i-1]的存储位置，虽然源代码里num的数组是从下标1开始使用的，但是生成的汇编代码还是从num[0]开始使用的
        subl    $8, %esp        # 扩栈
        pushl   %eax            # 存放位置入栈，作为scanf的参数
        pushl   $.LC0           # $.LC0入栈，scanf的参数
        call    __isoc99_scanf  # scanf，输入num[i]
        addl    $16, %esp       # 退栈
        addl    $1, -24(%ebp)   # i++ 
.L8:
        movl    -28(%ebp), %eax # %eax=n
        cmpl    %eax, -24(%ebp) # 比较i与n,此为for循环的结束条件
        jle     .L9             # 若i<=n,就执行循环体L9
        movl    -28(%ebp), %eax # 出循环,num都输入完毕，eax=n
        subl    $8, %esp        # 扩栈
        pushl   -16(%ebp)       # num的首位置入栈
        pushl   %eax            # n 入栈
        call    mysort          # mysort,这个函数需要两个参数，一个是n，一个是num的首地址，都已经入栈
        addl    $16, %esp       # 排序执行完毕，退栈
        movl    $1, -20(%ebp)   # 准备for循环输出，j=1，这里的j其实是源代码里的i
        jmp     .L10            # 跳转到L10
.L11:
        # 以下代码的逻辑与L9基本一致，L9是循环输入，这一段是循环输出
        movl    -20(%ebp), %eax # %eax=j
        leal    0(,%eax,4), %edx# %edx=j*4
        movl    -16(%ebp), %eax # $eax=num[]
        addl    %edx, %eax      # %eax=j+num[],即num[j]的存储位置     
        movl    (%eax), %eax    # %eax=num[j]
        subl    $8, %esp        # 扩栈
        pushl   %eax            # num[j]入栈，作为printf的参数
        pushl   $.LC1           # $.LC1入栈
        call    printf          # 调用printf
        addl    $16, %esp       # 退栈
        addl    $1, -20(%ebp)   # j++
.L10:
        movl    -28(%ebp), %eax # %eax=n
        cmpl    %eax, -20(%ebp) # 比较j和n
        jle     .L11            # 若j<=n,执行循环体L11
        movl    $0, %eax        # 出循环，%eax=0
        movl    -12(%ebp), %ecx # 取出-12位置的值，即最早存入的%gs:20
        xorl    %gs:20, %ecx    # 与%gs:20作比较
        je      .L13            # 如果相等，执行L13
                                # 经查阅资料，%gs:20的作用是判断堆栈是否损坏。这种叫做Stack canaries, 堆栈金丝雀 
        call    __stack_chk_fail# 如果不相等，执行堆栈检查错误的的子函数        
.L13:
        movl    -4(%ebp), %ecx  # 堆栈检查没问题，%ecx=执行main函数之前的基址
        .cfi_def_cfa 1, 0
        leave                   # 弹出当前函数基址 pop      
        .cfi_restore 5                  
        leal    -4(%ecx), %esp  # 恢复执行main函数之前的%esp
        .cfi_def_cfa 4, 4
        ret                     # main函数返回
        .cfi_endproc
.LFE3:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits
```

#### gcc64位

```assembly
        .file   "sort.c"
        .text
        .globl  mysort
        .type   mysort, @function
mysort:
.LFB2:
        .cfi_startproc
        pushq   %rbp            # 保存main函数的%ebp
                                # 被调用者保存
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    %edi, -20(%rbp)
        movq    %rsi, -32(%rbp)
        movl    $1, -12(%rbp)   # i=1
        jmp     .L2
.L6:                            # 第一层循环的循环体
        movl    $1, -8(%rbp)
        jmp     .L3
.L5:                             # 第二层循环的循环体
        movl    -8(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -32(%rbp), %rax
        addq    %rdx, %rax
        movl    (%rax), %edx
        movl    -8(%rbp), %eax
        cltq
        addq    $1, %rax
        leaq    0(,%rax,4), %rcx
        movq    -32(%rbp), %rax
        addq    %rcx, %rax
        movl    (%rax), %eax
        cmpl    %eax, %edx
        jle     .L4
        movl    -8(%rbp), %eax  # 执行交换操作
        cltq
        addq    $1, %rax
        leaq    0(,%rax,4), %rdx
        movq    -32(%rbp), %rax
        addq    %rdx, %rax
        movl    (%rax), %eax
        movl    %eax, -4(%rbp)
        movl    -8(%rbp), %eax
        cltq
        addq    $1, %rax
        leaq    0(,%rax,4), %rdx
        movq    -32(%rbp), %rax
        addq    %rax, %rdx
        movl    -8(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rcx
        movq    -32(%rbp), %rax
        addq    %rcx, %rax
        movl    (%rax), %eax
        movl    %eax, (%rdx)
        movl    -8(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -32(%rbp), %rax
        addq    %rax, %rdx
        movl    -4(%rbp), %eax
        movl    %eax, (%rdx)
.L4:
        addl    $1, -8(%rbp)    # j++
.L3:
        movl    -8(%rbp), %eax
        cmpl    -20(%rbp), %eax
        jl      .L5
        addl    $1, -12(%rbp)
.L2:
        movl    -12(%rbp), %eax
        cmpl    -20(%rbp), %eax
        jle     .L6
        nop
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret                     # 出循环，mysort函数结束
        .cfi_endproc
.LFE2:
        .size   mysort, .-mysort
        .section        .rodata
.LC0:
        .string "%d"
.LC1:
        .string "%d "
        .text
        .globl  main
        .type   main, @function
main:
.LFB3:
        .cfi_startproc
        pushq   %rbp            # 保存之前函数的基址
        .cfi_def_cfa_offset 16  
        .cfi_offset 6, -16
        movq    %rsp, %rbp      # %rbp=%rsp
        .cfi_def_cfa_register 6
        subq    $32, %rsp       
        movq    %fs:40, %rax    # 执行堆栈检查用
        movq    %rax, -8(%rbp)
        xorl    %eax, %eax      # %eax=0
        leaq    -28(%rbp), %rax 
        movq    %rax, %rsi
        movl    $.LC0, %edi
        movl    $0, %eax        # 用寄存器保存参数
        call    __isoc99_scanf  # 执行scanf
        movl    -28(%rbp), %eax 
        cltq                    # cltq将EAX签名扩展为RAX。它是movslq %eax, %rax的简短形式，节省了代码字节
        salq    $2, %rax
        movq    %rax, %rdi
        call    malloc          # malloc 
        movq    %rax, -16(%rbp) 
        movl    $1, -24(%rbp)
        jmp     .L8
.L9:
        movl    -24(%rbp), %eax
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -16(%rbp), %rax
        addq    %rdx, %rax
        movq    %rax, %rsi
        movl    $.LC0, %edi
        movl    $0, %eax
        call    __isoc99_scanf
        addl    $1, -24(%rbp)
.L8:
        movl    -28(%rbp), %eax # %eax=n
        cmpl    %eax, -24(%rbp) # i与n比较
        jle     .L9
        movl    -28(%rbp), %eax
        movq    -16(%rbp), %rdx
        movq    %rdx, %rsi
        movl    %eax, %edi
        call    mysort          # mysort
        movl    $1, -20(%rbp)
        jmp     .L10
.L11:
        movl    -20(%rbp), %eax # #eax=j
        cltq
        leaq    0(,%rax,4), %rdx
        movq    -16(%rbp), %rax
        addq    %rdx, %rax
        movl    (%rax), %eax
        movl    %eax, %esi
        movl    $.LC1, %edi
        movl    $0, %eax
        call    printf          # printf
        addl    $1, -20(%rbp)
.L10:
        movl    -28(%rbp), %eax
        cmpl    %eax, -20(%rbp) # 比较j和n
        jle     .L11
        movl    $0, %eax
        movq    -8(%rbp), %rcx
        xorq    %fs:40, %rcx
        je      .L13
        call    __stack_chk_fail
.L13:
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE3:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits
```

#### clang32位

```assembly
        .text
        .file   "sort.c"
        .globl  mysort                  # -- Begin function mysort
        .p2align        4, 0x90
        .type   mysort,@function
mysort:                                 # @mysort
# %bb.0:
        pushl   %ebp                    # 保存main函数的基址
        movl    %esp, %ebp
        subl    $12, %esp               # 扩栈
        movl    12(%ebp), %eax
        movl    8(%ebp), %ecx
        movl    $1, -4(%ebp)            # i=1
.LBB0_1:                                # =>This Loop Header: Depth=1
                                        #     Child Loop BB0_3 Depth 2
        movl    -4(%ebp), %eax
        cmpl    8(%ebp), %eax
        jg      .LBB0_10
# %bb.2:                                #   in Loop: Header=BB0_1 Depth=1
        movl    $1, -8(%ebp)
.LBB0_3:                                #   Parent Loop BB0_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
        movl    -8(%ebp), %eax
        cmpl    8(%ebp), %eax
        jge     .LBB0_8
# %bb.4:                                #   in Loop: Header=BB0_3 Depth=2
        movl    12(%ebp), %eax
        movl    -8(%ebp), %ecx
        movl    (%eax,%ecx,4), %eax
        movl    12(%ebp), %ecx
        movl    -8(%ebp), %edx
        cmpl    4(%ecx,%edx,4), %eax
        jle     .LBB0_6
# %bb.5:                                #   in Loop: Header=BB0_3 Depth=2
        movl    12(%ebp), %eax
        movl    -8(%ebp), %ecx
        movl    4(%eax,%ecx,4), %eax
        movl    %eax, -12(%ebp)
        movl    12(%ebp), %eax
        movl    -8(%ebp), %ecx
        movl    (%eax,%ecx,4), %eax
        movl    12(%ebp), %ecx
        movl    -8(%ebp), %edx
        movl    %eax, 4(%ecx,%edx,4)
        movl    -12(%ebp), %eax
        movl    12(%ebp), %ecx
        movl    -8(%ebp), %edx
        movl    %eax, (%ecx,%edx,4)
.LBB0_6:                                #   in Loop: Header=BB0_3 Depth=2
        jmp     .LBB0_7
.LBB0_7:                                #   in Loop: Header=BB0_3 Depth=2
        movl    -8(%ebp), %eax
        addl    $1, %eax
        movl    %eax, -8(%ebp)
        jmp     .LBB0_3
.LBB0_8:                                #   in Loop: Header=BB0_1 Depth=1
        jmp     .LBB0_9
.LBB0_9:                                #   in Loop: Header=BB0_1 Depth=1
        movl    -4(%ebp), %eax
        addl    $1, %eax
        movl    %eax, -4(%ebp)
        jmp     .LBB0_1
.LBB0_10:
        addl    $12, %esp
        popl    %ebp
        retl
.Lfunc_end0:
        .size   mysort, .Lfunc_end0-mysort
                                        # -- End function
        .globl  main                    # -- Begin function main
        .p2align        4, 0x90
        .type   main,@function
main:                                   # @main
# %bb.0:
        pushl   %ebp            # main函数之前的函数的基址入栈
        movl    %esp, %ebp      
        subl    $40, %esp       # 扩栈
        movl    $0, -4(%ebp)    
        leal    .L.str, %eax    
        movl    %eax, (%esp)
        leal    -8(%ebp), %eax  
        movl    %eax, 4(%esp)   # 函数的参数存在内存中
        calll   __isoc99_scanf  # scanf
        movl    -8(%ebp), %ecx
        shll    $2, %ecx
        movl    %ecx, (%esp)
        movl    %eax, -24(%ebp)         # 4-byte Spill
        calll   malloc          # malloc
        movl    %eax, -12(%ebp)
        movl    $1, -16(%ebp)   # i=1
.LBB1_1:                                # =>This Inner Loop Header: Depth=1
        movl    -16(%ebp), %eax # 取i
        cmpl    -8(%ebp), %eax  # i与n比较
        jg      .LBB1_4         # 若i>n,则跳转
# %bb.2:                                #   in Loop: Header=BB1_1 Depth=1
        movl    -12(%ebp), %eax #
        movl    -16(%ebp), %ecx
        shll    $2, %ecx
        addl    %ecx, %eax
        leal    .L.str, %ecx
        movl    %ecx, (%esp)
        movl    %eax, 4(%esp)
        calll   __isoc99_scanf  # scanf
# %bb.3:                                #   in Loop: Header=BB1_1 Depth=1
        movl    -16(%ebp), %eax
        addl    $1, %eax        # i++
        movl    %eax, -16(%ebp)
        jmp     .LBB1_1
.LBB1_4:
        movl    -8(%ebp), %eax  # n
        movl    -12(%ebp), %ecx # num起始地址
        movl    %eax, (%esp)
        movl    %ecx, 4(%esp)
        calll   mysort          # 调用mysort
        movl    $1, -20(%ebp)   # j
.LBB1_5:                                # =>This Inner Loop Header: Depth=1
        movl    -20(%ebp), %eax # 
        cmpl    -8(%ebp), %eax
        jg      .LBB1_8         # j>n
# %bb.6:                                #   in Loop: Header=BB1_5 Depth=1
        movl    -12(%ebp), %eax
        movl    -20(%ebp), %ecx
        movl    (%eax,%ecx,4), %eax
        leal    .L.str.1, %ecx
        movl    %ecx, (%esp)
        movl    %eax, 4(%esp)
        calll   printf          # printf
# %bb.7:                                #   in Loop: Header=BB1_5 Depth=1
        movl    -20(%ebp), %eax
        addl    $1, %eax        # j++
        movl    %eax, -20(%ebp)
        jmp     .LBB1_5
.LBB1_8:
        xorl    %eax, %eax      
        addl    $40, %esp
        popl    %ebp
        retl                    # return 0 
.Lfunc_end1:
        .size   main, .Lfunc_end1-main
                                        # -- End function
        .type   .L.str,@object          # @.str
        .section        .rodata.str1.1,"aMS",@progbits,1
.L.str:
        .asciz  "%d"
        .size   .L.str, 3

        .type   .L.str.1,@object        # @.str.1
.L.str.1:
        .asciz  "%d "
        .size   .L.str.1, 4

        .ident  "clang version 10.0.1 "
        .section        ".note.GNU-stack","",@progbits
        .addrsig
        .addrsig_sym mysort
        .addrsig_sym __isoc99_scanf
        .addrsig_sym malloc
        .addrsig_sym printf
```

#### clang64位

```assembly
        .text
        .file   "sort.c"
        .globl  mysort                  # -- Begin function mysort
        .p2align        4, 0x90
        .type   mysort,@function
mysort:                                 # @mysort
        .cfi_startproc
# %bb.0:
        pushq   %rbp            # 保存main的基址
        .cfi_def_cfa_offset 16
        .cfi_offset %rbp, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register %rbp
        movl    %edi, -4(%rbp)
        movq    %rsi, -16(%rbp) # 保存传过来的参数
        movl    $1, -20(%rbp)
.LBB0_1:                                # =>This Loop Header: Depth=1
                                        #     Child Loop BB0_3 Depth 2
        movl    -20(%rbp), %eax
        cmpl    -4(%rbp), %eax
        jg      .LBB0_10
# %bb.2:                                #   in Loop: Header=BB0_1 Depth=1
        movl    $1, -24(%rbp)
.LBB0_3:                                #   Parent Loop BB0_1 Depth=1
                                        # =>  This Inner Loop Header: Depth=2
        movl    -24(%rbp), %eax
        cmpl    -4(%rbp), %eax
        jge     .LBB0_8
# %bb.4:                                #   in Loop: Header=BB0_3 Depth=2
        movq    -16(%rbp), %rax
        movslq  -24(%rbp), %rcx
        movl    (%rax,%rcx,4), %edx
        movq    -16(%rbp), %rax
        movl    -24(%rbp), %esi
        addl    $1, %esi
        movslq  %esi, %rcx
        cmpl    (%rax,%rcx,4), %edx
        jle     .LBB0_6
# %bb.5:                                #   in Loop: Header=BB0_3 Depth=2
        movq    -16(%rbp), %rax
        movl    -24(%rbp), %ecx
        addl    $1, %ecx
        movslq  %ecx, %rdx
        movl    (%rax,%rdx,4), %ecx
        movl    %ecx, -28(%rbp)
        movq    -16(%rbp), %rax
        movslq  -24(%rbp), %rdx
        movl    (%rax,%rdx,4), %ecx
        movq    -16(%rbp), %rax
        movl    -24(%rbp), %esi
        addl    $1, %esi
        movslq  %esi, %rdx
        movl    %ecx, (%rax,%rdx,4)
        movl    -28(%rbp), %ecx
        movq    -16(%rbp), %rax
        movslq  -24(%rbp), %rdx
        movl    %ecx, (%rax,%rdx,4)
.LBB0_6:                                #   in Loop: Header=BB0_3 Depth=2
        jmp     .LBB0_7
.LBB0_7:                                #   in Loop: Header=BB0_3 Depth=2
        movl    -24(%rbp), %eax
        addl    $1, %eax
        movl    %eax, -24(%rbp)
        jmp     .LBB0_3
.LBB0_8:                                #   in Loop: Header=BB0_1 Depth=1
        jmp     .LBB0_9
.LBB0_9:                                #   in Loop: Header=BB0_1 Depth=1
        movl    -20(%rbp), %eax
        addl    $1, %eax
        movl    %eax, -20(%rbp)
        jmp     .LBB0_1
.LBB0_10:
        popq    %rbp
        .cfi_def_cfa %rsp, 8
        retq
.Lfunc_end0:
        .size   mysort, .Lfunc_end0-mysort
        .cfi_endproc
                                        # -- End function
        .globl  main                    # -- Begin function main
        .p2align        4, 0x90
        .type   main,@function
main:                                   # @main
        .cfi_startproc
# %bb.0:
        pushq   %rbp    
        .cfi_def_cfa_offset 16
        .cfi_offset %rbp, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register %rbp
        subq    $32, %rsp       # 扩栈       
        movl    $0, -4(%rbp)    
        movabsq $.L.str, %rdi   
        leaq    -8(%rbp), %rsi  # move指令的变种
        movb    $0, %al
        callq   __isoc99_scanf  # scanf
        movslq  -8(%rbp), %rcx
        shlq    $2, %rcx
        movq    %rcx, %rdi
        movl    %eax, -28(%rbp)         # 4-byte Spill
        callq   malloc          # malloc
        movq    %rax, -16(%rbp)
        movl    $1, -20(%rbp)
.LBB1_1:                                # =>This Inner Loop Header: Depth=1
        movl    -20(%rbp), %eax
        cmpl    -8(%rbp), %eax
        jg      .LBB1_4
# %bb.2:                                #   in Loop: Header=BB1_1 Depth=1
        movq    -16(%rbp), %rax
        movslq  -20(%rbp), %rcx
        shlq    $2, %rcx
        addq    %rcx, %rax
        movabsq $.L.str, %rdi
        movq    %rax, %rsi
        movb    $0, %al
        callq   __isoc99_scanf
# %bb.3:                                #   in Loop: Header=BB1_1 Depth=1
        movl    -20(%rbp), %eax
        addl    $1, %eax
        movl    %eax, -20(%rbp)
        jmp     .LBB1_1
.LBB1_4:
        movl    -8(%rbp), %edi
        movq    -16(%rbp), %rsi
        callq   mysort
        movl    $1, -24(%rbp)
.LBB1_5:                                # =>This Inner Loop Header: Depth=1
        movl    -24(%rbp), %eax
        cmpl    -8(%rbp), %eax
        jg      .LBB1_8
# %bb.6:                                #   in Loop: Header=BB1_5 Depth=1
        movq    -16(%rbp), %rax
        movslq  -24(%rbp), %rcx
        movl    (%rax,%rcx,4), %esi
        movabsq $.L.str.1, %rdi
        movb    $0, %al
        callq   printf
# %bb.7:                                #   in Loop: Header=BB1_5 Depth=1
        movl    -24(%rbp), %eax
        addl    $1, %eax
        movl    %eax, -24(%rbp)
        jmp     .LBB1_5
.LBB1_8:
        xorl    %eax, %eax
        addq    $32, %rsp
        popq    %rbp
        .cfi_def_cfa %rsp, 8
        retq
.Lfunc_end1:
        .size   main, .Lfunc_end1-main
        .cfi_endproc
                                        # -- End function
        .type   .L.str,@object          # @.str
        .section        .rodata.str1.1,"aMS",@progbits,1
.L.str:
        .asciz  "%d"
        .size   .L.str, 3

        .type   .L.str.1,@object        # @.str.1
.L.str.1:
        .asciz  "%d "
        .size   .L.str.1, 4

        .ident  "clang version 10.0.1 "
        .section        ".note.GNU-stack","",@progbits
        .addrsig
        .addrsig_sym mysort
        .addrsig_sym __isoc99_scanf
        .addrsig_sym malloc
        .addrsig_sym printf
```

