## 任务

+ 运行 demo
+ 在 `doc\answer.md` 中回答问题 1-1，1-2

## 要求的目录结构

```txt
demo
├── CMakeLists.txt
├── README.md
├── grammar
│   ├── demoParser.yy         # demo语言的语法描述
│   ├── demoScanner.ll        # demo语言的词法描述
│   └── test.sy               # 简单测试样例
├── include
│   ├── demoDriver.h          # demo语言前端的驱动器，驱动词法语法分析器工作
│   ├── demoFlexLexer.h       # demo语言的词法分析器包装类
│   ├── ErrorReporter.h       # 错误处理相关类的声明
│   ├── SyntaxTree.h          # 语法树节点的定义
│   └── SyntaxTreePrinter.h   # 根据语法树打印源代码
└── src
    ├── demoDriver.cpp         # demo语言前端的驱动器，驱动词法语法分析器工作
    ├── ErrorReporter.cpp      # 错误处理相关类的声明
    ├── main.cpp               # 主函数所在
    ├── SyntaxTree.cpp         # 语法树节点的方法实现
    └── SyntaxTreePrinter.cpp  # 根据语法树打印源代码
```

## 基本知识

### demo 介绍

+ demo 是一个 C 语言子集的前端

  + 不支持全局变量，源程序文件里面只可以包含一个函数定义，函数只能是void返回类型且不可以有参数；
  + 局部变量只能是int类型，不支持数组，局部变量可以初始化，支持十进制、八进制；
  + 不支持任何改变控制流的语句，即分支与循环；
  + 允许函数定义内部使用语句块；
  + 返回语句不是必需的，返回语句不能带有返回值；
  + 支持四则运算、取模运算、取负号以及取正号运算符，不支持任何逻辑运算符；
  + 语句可以是赋值语句、表达式语句、空语句、返回语句。

+ 该语言的文法采用的 EBNF 如下：

  ```c++
  CompUnit    → FuncDef
  FuncDef     → FuncType Ident '(' ')' Block
  FuncType    → 'void'
  Block       → '{' { BlockItem } '}'
  BlockItem   → VarDecl | Stmt
  VarDecl     → BType VarDef { ',' VarDef } ';'
  BType       → 'int'
  VarDef      → Ident | Ident '=' Exp
  Stmt        → LVal '=' Exp ';'
              | Exp ';'
              | 'return' ';'
              | Block
              | ';'
  LVal        → Ident
  Exp         → Exp BinOp Exp
              | UnaryOp Exp
              | '(' Exp ')'
              | LVal
              | Number
  Number      → IntConst
  BinOp       → '+' | '-' | '*' | '/' | '%'
  UnaryOp     → '+' | '-'
  ```

+ **使用 flex 构建词法分析器，bison 构建语法分析器**

+ 在语法分析的同时构建抽象语法树 AST

### demo 使用

+ 首先 make 
+ `./demo -[something]`
  + `-p`：输出**语法**分析详情
  + `-s`：输出**词法**分析详情
  + `-emit-ast`：通过 AST 复原代码，并输出
  + 当 `input-file` 为 `-` 时，将输入流切换为标准输入 

### Flex 词法描述

+ 接受此法描述文件，产生对应的词法分析器的 C 源代码
+ 声明部分：包含直接复制到生成代码的部分，以及词法符号的定义
+ 规则部分：
+ 代码部分：直接复制进词法分析器源码的尾部
+ Tips:
  + 当有多条规则的模式被匹配到时，会选择**匹配长度最长**的那条规则；如果有匹配长度相等的规则，则选择排在最前面的规则。
  + Flex生成的词法分析器中有许多预置的全局变量，其中`yytext`和`yyleng`表示刚刚匹配到的字符串以及它的长度。

### Bison 语法描述

+ LALR 文法
+ 冲突解决：Bison 会优先移进，建议使用优先和结合性的指令去显示声明记号的优先级和结合性，或者进一步对某条文法规则使用 `%prec` 生命按给定符号的优先级和结合性来处理该规则
+ 声明部分：直接复制的部分，token，优先级和结合性的声明，文法符号的语义值类型声明，开始声明
+ 规则部分：在语法分析阶段解决负号和减号的区别
+ 代码部分：`yyparse()` 是 Bison 生成的分析器的总控函数

### Bison 对 token 生成的对应函数

+ Bison 对于在语法描述文件中声明的每个 token，会在 .h 文件中生成对应的 make 函数

## 问题

### 问题1

#### `demoDriver.h`

+ ```c++
  std::map<std::string, int> variables;
  ```

+ ```c#
  // Run the parser on file F.
  // Return 0 on success.
  SyntaxTree::Node* parse(const std::string& f);
  ```

#### `demoDriver.cpp`

### 问题2

